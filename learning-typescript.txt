
- first dynamic programming languages with optional typing seems to have been common lisp (1985). Then came Typescript - since then lots of other dynamic programming language have adopted the idea (Python 3.5 https://docs.python.org/3/library/typing.html - 2015, PHP 7 - in 2015 ...)

- Javascript has lots of these supersets for adding optional typing: typescript (developed by Microsoft) there are others: Closure (google - https://developers.google.com/closure/compiler/) and flow (Facebook - https://flow.org/ )  ::: but Typescript is most popular (and the first one of these) Even javascript is working on a proposal! (https://github.com/tc39/proposal-type-annotations)

- typescript: superset of javascript, adds *optional* type annotation, acts as a preprocessor (translates *.ts into *.js)

    Typescript playground:  https://www.typescriptlang.org/play

    See short intro: https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html
    full book: https://www.typescriptlang.org/docs/handbook/2/basic-types.html
               https://www.typescriptlang.org/docs/handbook/2/objects.html

    Concise typescript book https://github.com/gibbok/typescript-book

- install it: https://www.typescriptlang.org/download
    npm install -g typescript
    tsc - that's the preprocessor, it is looking for tsconfig.js file - with lots of options... (but that is not mandatory!)

- basic types:
    string
    number
    boolean
    any         : opt-out of type checking. i
                  For variable of type any - one is allowed to access any member (just like in javascript) and assign it a value of any other type.

    undefined   : just like in javascript. Function that returns nothing - assigning the return value is value 'undefined'.
                    A variable declared as 'undefined' type can only have be assigned     value - undefined.
                        let a : undefined = undefined
    
    null        : the type of the null value. 
                    A variable declared as 'null' type can only have be assigned     value - null. 
                        let a : null = null

                  Quick javascript reminder:

                    let a=null;
                    let b=undefined;

                    console.log(a==b); // true
                    console.log(a===b); // false
 
- arithmetics:
    in typescript you can't add a number to undefined - that's not allowed. In javascript adding number to undefined results in not a number NaN (!)

- if you change stuff, so that they don't comply - then you get a warning (by default)

        // declaration of a type in ts
        interface Point {
          x: number;
          y: number;
        }

        // p : Point = require argument p of type P
        function logPoint(p: Point) {
          console.log(`${p.x}, ${p.y}`);
        }

        // the proper declaration would be cont point : Point = { x : 12, y : 26 }
        const point = { x: 12, y: '26' };
        logPoint(point);

- now compiling this to javascript gives the warning (output is till generated by default, despite warning)
    /also note that all of the type declarations and uses have been erased from the compi, you get function logPoint(p) {..../

    tsc t.ts

    t.ts:14:10 - error TS2345: Argument of type '{ x: number; y: string; }' is not assignable to parameter of type 'Point'.
      Types of property 'y' are incompatible.
        Type 'string' is not assignable to type 'number'.

    14 logPoint(point);
                ~~~~~


    Found 1 error in t.ts:14

-- https://www.typescriptlang.org/tsconfig :: reference of tsconfig
-- generate a tsconfig.json file in current directory (all possible options appear as comments!)

    tsc --init 

-- edit tsconfig.json ::: comment out magic option that does not create json output file if errors have been detected !!!!
    
    "noEmitOnError": true,

-- other very nice options:

     "strict": true /* Enable all strict type-checking options. */,
    "strictNullChecks": true /* Enable strict null checks. */,
    "noImplicitReturns": true /* Report error when not all code paths in function return a value. */,
    "noFallthroughCasesInSwitch": true /* Report errors for fallthrough cases in switch statement. */,


=====

export class MyClass {
  // ? means myProperty is optional, and if no value is given, that the value will be set to “undefined”
  myProperty? : string;
}


====
-  structural typing - if two objects have the same shape, they are considered to be of the same type.


        // declaration of a type in ts
        interface Point {
          x: number;
          y: number;
        }

        // p : Point = require argument p of type P
        function logPoint(p: Point) {
          console.log(`${p.x}, ${p.y}`);
        }

        // the proper declaration would be cont point : Point = { x : 12, y : 26 }
        const point = { x: 12, y: 26 };
        logPoint(point);

    The rules for 'structural typing' : (i think that's where the mess starts... You need an IDE - lots and lots of rules here...)

        https://github.com/gibbok/typescript-book#structural-typing


        - A type 'X' is compatible with 'Y' if 'Y' has at least the same members as 'X'.
        - Function types
            - Function parameters are compared by types, not by their names:
            - Function return types must be the same:
            - The return type of a source function must be a subtype of the return type of a target function:

                let x = () => ({ a: 'A' });
                let y = () => ({ a: 'A', b: 'B' });
                x = y; // Valid
                y = x; // Invalid member b is missing

        - Discarding function parameters is allowed !!!
                
                type X = (a: number) => undefined;
                type Y = (a: number, b: number) => undefined;
                let x: X = (a: number) => undefined;
                let y: Y = (a: number) => undefined; // Missing b parameter
                y = x; // Valid

        - Any additional optional parameters of the source type are valid:

                type X = (a: number, b?: number, c?: number) => undefined;
                type Y = (a: number) => undefined;
                let x: X = a => undefined;
                let y: Y = a => undefined;
                y = x; // Valid
                x = y; //Valid
                        
        - Any optional parameters of the target type without corresponding parameters in the source type are valid and not an error:

                type X = (a: number) => undefined;
                type Y = (a: number, b?: number) => undefined;
                let x: X = a => undefined;
                let y: Y = a => undefined;
                y = x; // Valid
                x = y; // Valid

        - typescript has function overloading! (Javascript doesn't have that - last function with a name is what counts)
    

