
- History lesson: 
    first dynamic programming languages with optional typing seems to have been common lisp (1985). 
    Then came others. 
        - Typescript,  
        - (Python 3.5 have type hints (though this is not always used for type checking) https://docs.python.org/3/library/typing.html - 2015, PHP 7 - in 2015 ...)
    The feature has many uses other than type checking: completion in an IDE can be guided by this, automatic generation of documentation (javadoc like), etc. etc.

- Javascript has seen lots of attempts to add a language extension that compiles down to javascript: (all with the purpose of 'adding types')
    - typescript (developed by Microsoft)  /it's the most popular from the crowd/
    - Closure (google - https://developers.google.com/closure/compiler/) 
    - flow (Facebook - https://flow.org/ )  
    - even javascript is working on a proposal! (https://github.com/tc39/proposal-type-annotations) /interesting; will that one get all the complexities of typescript?/
        

- typescript: superset of javascript, adds *optional* type annotation, acts as a preprocessor (translates *.ts into *.js)

    Typescript playground:  https://www.typescriptlang.org/play

    See short intro: https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html
    full book: https://www.typescriptlang.org/docs/handbook/2/basic-types.html
               https://www.typescriptlang.org/docs/handbook/2/objects.html

    Concise typescript book https://github.com/gibbok/typescript-book

- install it: https://www.typescriptlang.org/download
    npm install -g typescript
    tsc - that's the preprocessor, it is looking for tsconfig.js file - with lots of options... (but that is not mandatory!)

- basic types:
    string
    number
    boolean
    any         : opt-out of type checking. i
                  For variable of type any - one is allowed to access any member (just like in javascript) and assign it a value of any other type.

    undefined   : just like in javascript. Function that returns nothing - assigning the return value is value 'undefined'.
                    A variable declared as 'undefined' type can only have be assigned value - undefined.
                        let a : undefined = undefined
    
    null        : the type of the null value. 
                    A variable declared as 'null' type can only have be assigned     value - null. 
                        let a : null = null

                  Quick javascript reminder:

                    let a=null;
                    let b=undefined;

                    console.log(a==b); // true
                    console.log(a===b); // false
 
- type inference
    let a = "blabla"; // this one is easy, the compiler can infer the type, it's string\
    let a : string = "blabla"; // not needed as such, this form declares the type of variable a explicitly

- method parameters and return values: if you declare a argument type/return value then it will be enforced (logical thing to do)

    function foo(a : string) : number {
        return 1 + parseFloat(a)
    }

- arithmetics:
    in typescript you can't add a number to undefined - that's not allowed. 
    In javascript adding number to undefined results in not a number NaN (!!!)

- if you change stuff, so that they don't comply - then you get a warning (by default)

        // declaration of a type in ts
        interface Point {
          x: number;
          y: number;
        }

        // p : Point = require argument p of type P
        function logPoint(p: Point) {
          console.log(`${p.x}, ${p.y}`);
        }

        // the proper declaration would be cont point : Point = { x : 12, y : 26 }
        const point = { x: 12, y: '26' };
        logPoint(point);

- now compiling this to javascript gives the warning (output is till generated by default, despite warning)
    /also note that all of the type declarations and uses have been erased from the compi, you get function logPoint(p) {..../

    tsc t.ts

    t.ts:14:10 - error TS2345: Argument of type '{ x: number; y: string; }' is not assignable to parameter of type 'Point'.
      Types of property 'y' are incompatible.
        Type 'string' is not assignable to type 'number'.

    14 logPoint(point);
                ~~~~~


    Found 1 error in t.ts:14

-- https://www.typescriptlang.org/tsconfig :: reference of tsconfig
-- generate a tsconfig.json file in current directory (all possible options appear as comments!)

    tsc --init 

-- edit tsconfig.json ::: comment out magic option that does not create json output file if errors have been detected !!!!
    
    "noEmitOnError": true,

-- other very nice options:

    "strict": true /* Enable all strict type-checking options. */,
    "strictNullChecks": true /* Enable strict null checks. */,
    "noImplicitReturns": true /* Report error when not all code paths in function return a value. */,
    "noFallthroughCasesInSwitch": true /* Report errors for fallthrough cases in switch statement. */,
    ״noImplicitAny״ - typescript can't infer a type? defaul behavior is to assign it the 'any' type (that's the default javascript behavior). This option marks such cases as an error - it's a king of 'no to javascript compatibility, super strict mode'

=====

Types 

    // type NumOrString can either be a Number or a String - that's a Union type!

    type NumOrString = Number | String

    function add(arg : NumOrString) {
        if (typeof arg === "number") {
            return 1 + arg;  // if you want to use any alternative - then you have to check the type before use!
        }
        if (typeof arg === "string") {
            return parseInt(arg) + 1
        }
        return -1; // without this you get error: "Not all code paths return a value"
    }

    // but you can do a better exhaustive check with if .. else 

    function add(arg : NumOrString) {
        if (typeof arg === "number") {
            return 1 + arg;  // if you want to use any alternative - then you have to check the type before use!
        } else { // arg === "string is assumed
            return parseInt(arg) + 1
        }
    }


    // a constant is also a type (a Literal type), and you can have enumerations, by chaining constants up with | 
    // a enumeration as a union of constants
    type Direction = "left" | "right" | "up" | "down"

    type Pos = {
        x: number;
        y: number;
    }

    function goTo( arg: Pos, dir : Direction) : Pos {

        if (dir == "left") { // now you need to check for possible values to deal with the enumeration
            return { x: arg.x-1, y: arg.y };
        }
        if (dir == "right") {
            return { x: arg.x+1, y: arg.y };
        }
        if (dir == "up") {
            return { x: arg.x, y: arg.y-1 };
        }

        if (dir == "down") {
            return { x: arg.x, y: arg.y+1 };
        }

        return arg;
    }

Exntending
    - derive from type to add a field into the derived type

        interface Animal {
            name: string
        }
        interface Bear extends Animal {
            honey: boolean
        }

    - define a new interface as intersection of two types (the result of the intersection has additional fields)

        type Animal = {
            name: string
        }
        type Bear = Animal & {
            honey: boolean
        }

    - with interface you can do the following to add a field (you can't do that redefining with type declarations !!!)

        interface Window {
            title: string
        }
        interface Window {
            ts: TypeScriptAPI
        }


=====

export class MyClass {
  // ? means myProperty is optional, and if no value is given, that the value will be set to “undefined”
  myProperty? : string;
}


====
-  structural typing - if two objects have the same shape, they are considered to be of the same type.


        // declaration of a type in ts
        interface Point {
          x: number;
          y: number;
        }

        // p : Point = require argument p of type P
        function logPoint(p: Point) {
          console.log(`${p.x}, ${p.y}`);
        }

        // the proper declaration would be cont point : Point = { x : 12, y : 26 }
        const point = { x: 12, y: 26 };
        logPoint(point);

    The rules for 'structural typing' : (i think that's where the mess starts... You need an IDE - lots and lots of rules here...)

        https://github.com/gibbok/typescript-book#structural-typing


        - A type 'X' is compatible with 'Y' if 'Y' has at least the same members as 'X'.
        - Function types
            - Function parameters are compared by types, not by their names:
            - Function return types must be the same:
            - The return type of a source function must be a subtype of the return type of a target function:

                let x = () => ({ a: 'A' });
                let y = () => ({ a: 'A', b: 'B' });
                x = y; // Valid
                y = x; // Invalid member b is missing

        - Discarding function parameters is allowed !!!
                
                type X = (a: number) => undefined;
                type Y = (a: number, b: number) => undefined;
                let x: X = (a: number) => undefined;
                let y: Y = (a: number) => undefined; // Missing b parameter
                y = x; // Valid

        - Any additional optional parameters of the source type are valid:

                type X = (a: number, b?: number, c?: number) => undefined;
                type Y = (a: number) => undefined;
                let x: X = a => undefined;
                let y: Y = a => undefined;
                y = x; // Valid
                x = y; //Valid
                        
        - Any optional parameters of the target type without corresponding parameters in the source type are valid and not an error:

                type X = (a: number) => undefined;
                type Y = (a: number, b?: number) => undefined;
                let x: X = a => undefined;
                let y: Y = a => undefined;
                y = x; // Valid
                x = y; // Valid

        - typescript has function overloading! (Javascript doesn't have that - last function with a name is what counts)
    

-- Arrays:
    
        
