
- History lesson: 
    first dynamic programming languages with optional typing seems to have been common lisp (1985). 
    Then came others. 
        - Typescript,  
        - (Python 3.5 have type hints (though this is not always used for type checking) https://docs.python.org/3/library/typing.html - 2015, PHP 7 - in 2015 ...)
    The feature has many uses other than type checking: completion in an IDE can be guided by this, automatic generation of documentation (javadoc like), etc. etc.

- Javascript has seen lots of attempts to add a language extension that compiles down to javascript: (all with the purpose of 'adding types')
    - typescript (developed by Microsoft)  /it's the most popular from the crowd/
    - Closure (google - https://developers.google.com/closure/compiler/) 
    - flow (Facebook - https://flow.org/ )  
    - even javascript is working on a proposal! (https://github.com/tc39/proposal-type-annotations) /interesting; will that one get all the complexities of typescript?/
        

- typescript: superset of javascript, adds *optional* type annotation, acts as a preprocessor (translates *.ts into *.js)

    Typescript playground:  https://www.typescriptlang.org/play

    See short intro: https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html
    full book: https://www.typescriptlang.org/docs/handbook/2/basic-types.html
               https://www.typescriptlang.org/docs/handbook/2/objects.html

    Concise typescript book https://github.com/gibbok/typescript-book

- install it: https://www.typescriptlang.org/download
    npm install -g typescript
    tsc - that's the preprocessor, it is looking for tsconfig.js file - with lots of options... (but that is not mandatory!)

- basic types:
    string
    number
    boolean
    any         : opt-out of type checking. i
                  For variable of type any - one is allowed to access any member (just like in javascript) and assign it a value of any other type.

    undefined   : just like in javascript. Function that returns nothing - assigning the return value is value 'undefined'.
                    A variable declared as 'undefined' type can only have be assigned value - undefined.
                        let a : undefined = undefined
    
    null        : the type of the null value. 
                    A variable declared as 'null' type can only have be assigned     value - null. 
                        let a : null = null

                  Quick javascript reminder:

                    let a=null;
                    let b=undefined;

                    console.log(a==b); // true
                    console.log(a===b); // false

     void       : return type that has no value. A variable of type void can have value null or undefined (why?)

     never      : placeholder type that is 'never' going to occur. A variable of type never can't have any value...

 
- type inference
    let a = "blabla"; // this one is easy, the compiler can infer the type, it's string\
    let a : string = "blabla"; // not needed as such, this form declares the type of variable a explicitly

- method parameters and return values: if you declare a argument type/return value then it will be enforced (logical thing to do)

    function foo(a : string) : number {
        return 1 + parseFloat(a)
    }

- arithmetics:
    in typescript you can't add a number to undefined - that's not allowed. 
    In javascript adding number to undefined results in not a number NaN (!!!)

- if you change stuff, so that they don't comply - then you get a warning (by default)

        // declaration of a type in ts
        interface Point {
          x: number;
          y: number;
        }

        // p : Point = require argument p of type P
        function logPoint(p: Point) {
          console.log(`${p.x}, ${p.y}`);
        }

        // the proper declaration would be cont point : Point = { x : 12, y : 26 }
        const point = { x: 12, y: '26' };
        logPoint(point);

- now compiling this to javascript gives the warning (output is till generated by default, despite warning)
    /also note that all of the type declarations and uses have been erased from the compi, you get function logPoint(p) {..../

    tsc t.ts

    t.ts:14:10 - error TS2345: Argument of type '{ x: number; y: string; }' is not assignable to parameter of type 'Point'.
      Types of property 'y' are incompatible.
        Type 'string' is not assignable to type 'number'.

    14 logPoint(point);
                ~~~~~


    Found 1 error in t.ts:14

-- https://www.typescriptlang.org/tsconfig :: reference of tsconfig
-- generate a tsconfig.json file in current directory (all possible options appear as comments!)

    tsc --init 

-- edit tsconfig.json ::: comment out magic option that does not create json output file if errors have been detected !!!!
    
    "noEmitOnError": true,

-- other very nice options:

    "strict": true /* Enable all strict type-checking options. */,
    "strictNullChecks": true /* Enable strict null checks. */,
    "noImplicitReturns": true /* Report error when not all code paths in function return a value. */,
    "noFallthroughCasesInSwitch": true /* Report errors for fallthrough cases in switch statement. */,
    ״noImplicitAny״ - typescript can't infer a type? defaul behavior is to assign it the 'any' type (that's the default javascript behavior). This option marks such cases as an error - it's a king of 'no to javascript compatibility, super strict mode'

=====

Types 

        // type NumOrString can either be a Number or a String - that's a Union type!

        type NumOrString = Number | String

        function add(arg : NumOrString) {
            if (typeof arg === "number") { // that's called 'Narrowing' - need to check which type applies - of this union type.
                return 1 + arg;  // if you want to use any alternative - then you have to check the type before use!
            }
            if (typeof arg === "string") {
                return parseInt(arg) + 1
            }
            return -1; // without this you get error: "Not all code paths return a value"
        }

        // but you can do a better exhaustive check with if .. else 

        function add(arg : NumOrString) {
            if (typeof arg === "number") { // that's called 'Narrowing' - need to check which type applies - of this union type.
                return 1 + arg;  // if you want to use any alternative - then you have to check the type before use!
            } else { // arg === "string is assumed
                return parseInt(arg) + 1
            }
        }


        // a constant is also a type (a Literal type), and you can have enumerations, by chaining constants up with | 
        // a enumeration as a union of constants
        type Direction = "left" | "right" | "up" | "down"

        type Pos = {
            x: number;
            y: number;
        }

        function goTo( arg: Pos, dir : Direction) : Pos {

            if (dir == "left") { // now you need to check for possible values to deal with the enumeration
                return { x: arg.x-1, y: arg.y };
            }
            if (dir == "right") {
                return { x: arg.x+1, y: arg.y };
            }
            if (dir == "up") {
                return { x: arg.x, y: arg.y-1 };
            }

            if (dir == "down") {
                return { x: arg.x, y: arg.y+1 };
            }

            return arg;
        }

    "Truthy" is a javascript thing: it means that variable passes boolean check (if (var) {...) 
    Value is "truthy" - if it is not either one of: false, 0, -0, 0n, "", null, undefined, NaN. (if it has one of these value then it's "falsy")

    A variable is "Truthy" if it is not null or undefined. Checking for "truthyness" (that's a typescript term)

        function checkTruthy(a : string | null | undefined) {
            if (a) { // check if it is "Truthy"
                console.log(`a is truthy (not null or undefined): ${a}`)
            } else {
                console.log(`a is not truthy ${a}`);
            }
        }

        checkTruthy(null);
        checkTruthy(undefined);
        checkTruthy("blabla");
        checkTruthy(""); // that's the problem case! the check if (a) is false for empty strings!!!
        
    A better check - this one is identifying "" as 'truthly', still 'undefined' is identified as 'not truthly'!

        function checkTruthy(a : string | null | undefined) {
            if (a == null) { // == null is true for null and undefined - but not for empty string !!!!
                console.log(`a is not truthy ${a}`);
            } else {
                console.log(`a is truthy (not null or undefined): ${a}`)
            }
        }

        checkTruthy(null);
        checkTruthy(undefined);
        checkTruthy("blabla");
        checkTruthy("");

    Type predicates - a function that validates if a variable is of a given type.

        // Example type validation of strings.
        
        function isString(val : unknown) : val is string {
            return typeof val === 'string';
        }

        let a="aaa";

        if (isString(a)) {
            console.log("value a is a string");
        }

        let b=12;

        if (!isString(b)) {
            console.log("value b is not a string");
        }

    
    Non null assertion operator !

        function incIt(val : number | undefined | null) : number {
            //return val + 1;  // can't do that null + 1 is not allowed in typescript
            return val! + 1;   // the ! asserts that the value is not null - it just ignores the typecheck of typescript
                               // (the assertion doesn't mean that a runtime check is done - it just ignores the typecheck!)
                               // it may actually crash at runtime because of that!!!
                               // see https://stackoverflow.com/questions/38874928/operator-in-typescript-after-object-method
        }

        console.log(incIt(undefined)); // NaN (in javascript undefined + 1 == NaN)

        console.log(incIt(1)); // 2

   Where  would you need that null assertion operator?

        // discriminating union: radius is set if kind is "circle", sideLength is set  if kind is "square"
        // but there is no way for the typechecker to know which one is valid.
        // ... so they provide a way to ignore all of the typescript typechecking goodness - at your own peril!

        interface Shape {
            kind: "circle" | "square";
            radius?: number;
            sideLength?: number;
        }

   Callback function types

        type LogFunctionCB = (a: string) => void;

        function doSomething(logFunc : LogFunctionCB) {

            logFunc("hello world");
        }

        function logIt(msg : string) {
            console.log(`Msg ${msg}`);
        }

        doSomething(logIt);

Exntending interfaces vs extending types

    - derive from type to add a field into the derived type

        interface Animal {
            name: string
        }
        interface Bear extends Animal {
            honey: boolean
        }

    - define a new interface as intersection of two types (the result of the intersection has additional fields)

        type Animal = {
            name: string
        }
        type Bear = Animal & {
            honey: boolean
        }

    - with interface you can do the following to add a field (you can't do that redefining with type declarations !!!)

        interface Window {
            title: string
        }
        interface Window {
            ts: TypeScriptAPI
        }


=== 
    Continuation of 'Non null assertion operator !'
    A better way to do discriminating unions: (much better)



        interface Circle {
            kind: "circle";
            radius: number;
        }
        interface Square {
            kind: "square";
            sideLength: number;
        }

        type Shape = Circle | Square;

        function getArea(shape: Shape) {
            switch (shape.kind) {
                case "circle":
                    return Math.PI * shape.radius ** 2;
                case "square":
                    return shape.sideLength ** 2;
                default:
                    const _exhaustiveCheck: never = shape;
                    return _exhaustiveCheck;
            }
        }    
=====

export class MyClass {
  // ? means myProperty is optional, and if no value is given, that the value will be set to “undefined”
  myProperty? : string;
}


====
-  structural typing - if two objects have the same shape, they are considered to be of the same type.


        // declaration of a type in ts
        interface Point {
          x: number;
          y: number;
        }

        // p : Point = require argument p of type P
        function logPoint(p: Point) {
          console.log(`${p.x}, ${p.y}`);
        }

        // the proper declaration would be cont point : Point = { x : 12, y : 26 }
        const point = { x: 12, y: 26 };
        logPoint(point);

    The rules for 'structural typing' : (i think that's where the mess starts... You need an IDE - lots and lots of rules here...)

        https://github.com/gibbok/typescript-book#structural-typing


        - A type 'X' is compatible with 'Y' if 'Y' has at least the same members as 'X'.
        - Function types
            - Function parameters are compared by types, not by their names:
            - Function return types must be the same:
            - The return type of a source function must be a subtype of the return type of a target function:

                let x = () => ({ a: 'A' });
                let y = () => ({ a: 'A', b: 'B' });
                x = y; // Valid
                y = x; // Invalid member b is missing

        - Discarding function parameters is allowed !!!
                
                type X = (a: number) => undefined;
                type Y = (a: number, b: number) => undefined;
                let x: X = (a: number) => undefined;
                let y: Y = (a: number) => undefined; // Missing b parameter
                y = x; // Valid

        - Any additional optional parameters of the source type are valid:

                type X = (a: number, b?: number, c?: number) => undefined;
                type Y = (a: number) => undefined;
                let x: X = a => undefined;
                let y: Y = a => undefined;
                y = x; // Valid
                x = y; //Valid
                        
        - Any optional parameters of the target type without corresponding parameters in the source type are valid and not an error:

                type X = (a: number) => undefined;
                type Y = (a: number, b?: number) => undefined;
                let x: X = a => undefined;
                let y: Y = a => undefined;
                y = x; // Valid
                x = y; // Valid

        - typescript has function overloading! (Javascript doesn't have that - last function with a name is what counts)
    

-- Arrays:
    
        
