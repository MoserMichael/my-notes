

                  |  
           |      |
  |        |   :  |
  |     |  |   :  | 
  __________________

Question: Towers, get the highest square enclosed between any two elements

Solution:
    - stable sort the entries by their hight, or each element, find it in this structure (can make this a lookup)

    - find the next element in the sorted structure and compute the enclosed square; (maintain a maximum value in the process)


Question: check if pairing 
    check('{[()]}', true)
    check('{[()]}(', false)

Solution:
    Evaluate the expression on a stack. (if it's a starting symbol - push, if it's an ending symbol - pop (should be a matching one))
    watch for stack underflows - that's an error.

---

They like questions on breadth-first-search vs deep-first-search
    - prefer depth-first-search if there are no bounds on the depth of the search tree
    - go for sparse representation, if the bounds are not defined (need to define the API in layers)

---

Question: Validate binary search tree
    - each node should be in a range of valid values,
    - make a recursive procedure, arguments are the min and max values of the valid range, check if the root node is valid, 
        - if yes call recursively on child nodes, while adjusting the parameters for valid range


--- horn form - evaluation of polynomials

    9 * x ^ 4 + 3*x^3 + x^2 + 2x + 5

    9 * x + 3

    x *  (9 * x + 3) + x
          ---------

    x * (x *  (9 * x + 3) + x) + 2 
         --------------------

    x * (x * (x *  (9 * x + 3) + x) + 2) + 5
         ------------------------------


